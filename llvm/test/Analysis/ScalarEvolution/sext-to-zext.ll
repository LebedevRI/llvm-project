; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt -disable-output "-passes=print<scalar-evolution>" < %s 2>&1 | FileCheck %s

define void @f(i1 %c) {
; CHECK-LABEL: 'f'
; CHECK-NEXT:  Classifying expressions for: @f
; CHECK-NEXT:    %start = select i1 %c, i32 100, i32 0
; CHECK-NEXT:    --> (100 + (-100 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>)) U: [100,1) S: [100,1)
; CHECK-NEXT:    %step = select i1 %c, i32 -1, i32 1
; CHECK-NEXT:    --> (-1 + (2 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>))<nsw> U: [-1,2) S: [-1,2)
; CHECK-NEXT:    %iv = phi i32 [ %start, %entry ], [ %iv.dec, %loop ]
; CHECK-NEXT:    --> {(100 + (-100 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>)),+,(-1 + (2 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>))<nsw>}<nsw><%loop> U: [0,101) S: [0,101) Exits: (1 + (99 * (2 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>))<nuw><nsw> + (-100 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>)) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.tc = phi i32 [ 0, %entry ], [ %iv.tc.inc, %loop ]
; CHECK-NEXT:    --> {0,+,1}<%loop> U: [0,100) S: [0,100) Exits: 99 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.tc.inc = add i32 %iv.tc, 1
; CHECK-NEXT:    --> {1,+,1}<%loop> U: [1,101) S: [1,101) Exits: 100 LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.dec = add nsw i32 %iv, %step
; CHECK-NEXT:    --> {(99 + (2 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>) + (-100 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>)),+,(-1 + (2 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>))<nsw>}<nw><%loop> U: full-set S: full-set Exits: ((100 * (2 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>))<nuw><nsw> + (-100 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>)) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:    %iv.sext = sext i32 %iv to i64
; CHECK-NEXT:    --> {(sext i32 (100 + (-100 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>)) to i64),+,(-1 + (zext i32 (2 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>) to i64))<nsw>}<nsw><%loop> U: [-2147483747,2147483747) S: [-2147483747,2147483747) Exits: (-99 + (sext i32 (100 + (-100 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>)) to i64) + (99 * (zext i32 (2 umin (-1 + (-1 * (sext i1 %c to i32))<nsw>)<nsw>) to i64))<nuw><nsw>) LoopDispositions: { %loop: Computable }
; CHECK-NEXT:  Determining loop execution counts for: @f
; CHECK-NEXT:  Loop %loop: backedge-taken count is 99
; CHECK-NEXT:  Loop %loop: max backedge-taken count is 99
; CHECK-NEXT:  Loop %loop: Predicated backedge-taken count is 99
; CHECK-NEXT:   Predicates:
; CHECK:       Loop %loop: Trip multiple is 100
;
entry:
  %start = select i1 %c, i32 100, i32 0
  %step =  select i1 %c, i32 -1,  i32 1
  br label %loop

loop:
  %iv = phi i32 [ %start, %entry ], [ %iv.dec, %loop ]
  %iv.tc = phi i32 [ 0, %entry ], [ %iv.tc.inc, %loop ]
  %iv.tc.inc = add i32 %iv.tc, 1
  %iv.dec = add nsw i32 %iv, %step
  %iv.sext = sext i32 %iv to i64
  %be = icmp ne i32 %iv.tc.inc, 100
  br i1 %be, label %loop, label %leave

leave:
  ret void
}
